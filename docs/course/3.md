---
title: 第 3 章：项目初始化与架构设计
createTime: 2025/11/13 20:45:45
permalink: /course/4vyujvpa/
---
# 第 3 章：项目初始化与架构设计

终于来到众目睽睽的项目初始化的环节了，我们将会在这一章完成项目的初始化，然后构建你全栈项目中的第一个 ==Hello World==！

## 3.1 项目初始化与代码规范

::: important ~~跟随教程进行项目初始化（划）~~ 完成项目初始化
其实你可以自己看他们的官方文档的 desu.....

[Nuxt 4 官方文档](https://nuxtjs.org.cn/)

[FastAPI 官方文档](https://fastapi.tiangolo.com/zh/)
:::

项目初始化是全栈开发的第一步，建立合理的项目结构和代码规范可以为后续开发奠定良好基础。本节将介绍前端和后端项目的初始化流程和推荐的代码规范。

### 3.1.1 前端项目初始化（Nuxt）

以下是初始化 Nuxt  项目的详细步骤：

```bash
# 1. 创建 Nuxt  项目（使用交互式命令）
pnpm create nuxt@latest frontend

# 2. 切换到项目目录
cd frontend

# 3. 安装依赖
pnpm install  # 推荐使用 pnpm
# 或者使用 npm
# npm install
# 或者使用 yarn
# yarn install

# 4. 启动开发服务器
pnpm run dev -- -o
# 然后可以在浏览器访问 http://localhost:3000

# 5. 安装代码规范工具
pnpm add -D eslint @nuxt/eslint-config prettier eslint-plugin-prettier eslint-config-prettier

# 6. 创建 ESLint 配置文件
# .eslintrc.js
module.exports = {
  extends: ['@nuxt/eslint-config', 'plugin:prettier/recommended'],
  rules: {
    // 自定义规则
  }
}

# 7. 创建 Prettier 配置文件
# .prettierrc
{
  "semi": false,
  "singleQuote": true,
  "trailingComma": "es5"
}
```

#### 3.1.1.1 推荐的前端项目结构
::: details 前端项目结构示例
```bash
personal-website/
├── .nuxt/            # Nuxt 构建缓存
├── .output/          # Nuxt 输出目录
├── assets/           # 静态资源（CSS、图片等）
│   ├── css/
│   └── images/
├── components/       # Vue 组件
│   ├── common/
│   └── layout/
├── composables/      # 组合式函数
├── layouts/          # 布局组件
├── middleware/       # 中间件
├── pages/            # 页面组件（自动生成路由）
│   ├── index.vue
│   └── about.vue
├── plugins/          # 插件
├── public/           # 静态资源（直接映射到根路径）
├── server/           # 服务端代码
│   ├── api/          # API 路由
│   └── middleware/
├── stores/           # Pinia 状态管理
├── .eslintrc.js      # ESLint 配置
├── .prettierrc       # Prettier 配置
├── nuxt.config.ts    # Nuxt 配置
├── package.json      # 项目依赖
└── tsconfig.json     # TypeScript 配置
```
:::

实际上，这只是一个示例，你可以在自己的项目中==遵循自己的最佳实践==，只不过本教程可能更偏向于使用这样的项目目录结构。

### 3.1.2 后端项目初始化（FastAPI）

FastAPI 是一个现代化、高性能的 Python Web 框架，适用于构建 API。以下是使用 PDM 初始化 FastAPI 项目的基本步骤：

#### 3.1.2.1 创建项目目录并初始化
```bash
mkdir backend && cd backend

# 使用 PDM 初始化项目（会自动创建虚拟环境）
pdm init
```

#### 3.1.2.2 安装项目依赖
```bash
# 安装主要依赖
pdm add fastapi uvicorn sqlalchemy pydantic-settings python-dotenv

# 安装开发依赖
pdm add -d pytest
pdm add -d black
pdm add -d isort 
```

#### 3.1.2.3 创建项目结构
```bash
mkdir -p app/{api,models,schemas,crud,database}
```

#### 3.1.2.4 推荐的后端项目结构

::: details 后端项目结构示例
```bash
backend/
├── app/              # 主应用目录
│   ├── __init__.py   # Python 包标识
│   ├── main.py       # 应用入口
│   ├── api/          # API 路由和端点
│   │   ├── __init__.py
│   │   ├── users.py
│   │   └── items.py
│   ├── models/       # 数据库模型
│   ├── schemas/      # Pydantic 模型（请求和响应）
│   ├── crud/         # 数据库操作
│   ├── database.py   # 数据库连接
│   └── config.py     # 配置管理
├── tests/            # 测试文件
├── .env              # 环境变量
├── .env.example      # 环境变量示例
├── requirements.txt  # 项目依赖
└── pyproject.toml    # 项目配置
```
:::

和前端项目一样，这只是一个示例，你可以根据自己的需求调整项目结构。

#### 3.1.2.5 一些代码规范

1. **前端代码规范**
   - 使用 TypeScript 进行类型检查
   - 遵循 Vue 3 的 Composition API 风格
   - 使用 ESLint 和 Prettier 保持代码风格一致
   - 为组件和函数添加适当的文档注释
   - 组件命名采用 PascalCase，Props 命名采用 camelCase

2. **后端代码规范**
   - 遵循 PEP 8 编码规范
   - 使用 Black、isort 和 Flake8 格式化和检查代码
   - 为 API 添加清晰的文档和请求/响应示例
   - 使用 Pydantic 进行数据验证
   - 实现适当的错误处理和日志记录

3. **通用规范**
   - 代码提交前运行格式化和检查工具
   - 编写单元测试和集成测试
   - 使用有意义的变量和函数名称
   - 保持函数的单一职责原则
   - 代码注释应解释"为什么"而不是"是什么"

#### 3.1.2.6 代码规范配置
TODO: 完善代码规范配置

## 3.2 API 接口设计规范

API 接口就像是前后端之间的「语言」，良好的 API 设计能让前后端协作更加顺畅。我们采用 RESTful 设计风格，制定了以下规范：

### 3.2.1 RESTful API 设计原则

RESTful API 设计就像设计一套标准化的沟通协议，让客户端和服务器能够高效地交流。以下是我们遵循的资源命名和接口设计规范：

```markdown
# 基础资源操作
GET    /api/v1/articles      # 获取文章列表 - 如同在图书馆查找书籍目录
POST   /api/v1/articles      # 创建新文章 - 如同在图书馆新增一本图书
GET    /api/v1/articles/{id} # 获取指定文章 - 如同查阅某本特定的图书
PUT    /api/v1/articles/{id} # 更新文章 - 如同修改图书内容
DELETE /api/v1/articles/{id} # 删除文章 - 如同从图书馆移除某本图书

# 用户资源操作
GET    /api/v1/users/{id}    # 获取指定用户信息
POST   /api/v1/users         # 创建新用户
PUT    /api/v1/users/{id}    # 更新用户信息
DELETE /api/v1/users/{id}    # 删除用户

# 嵌套资源操作（文章与评论的关系）
GET    /api/v1/articles/{id}/comments  # 获取文章评论 - 如同查看图书的读者留言
POST   /api/v1/articles/{id}/comments # 创建文章评论 - 如同添加新的读者留言
PUT    /api/v1/articles/{id}/comments/{comment_id} # 更新评论 - 如同修改已有的读者留言
DELETE /api/v1/articles/{id}/comments/{comment_id} # 删除评论 - 如同删除某条读者留言
```

### 3.2.2 响应格式标准化

标准化的响应格式就像统一的「信息模板」，让前端能够以一致的方式处理各种响应。我们定义了以下两种响应格式：

```typescript
// 成功响应 - 清晰地告知客户端操作成功及返回的数据
{ 
  "status": "success",     // 状态标识
  "data": {                // 响应数据主体
    "id": 1,
    "title": "文章标题",
    "content": "文章内容"
  },
  "message": "操作成功"    // 操作结果描述
}

// 错误响应 - 详细说明错误原因，帮助前端排查问题
{ 
  "status": "error",       // 状态标识
  "error": {               // 错误信息详情
    "code": "VALIDATION_ERROR",      // 错误代码
    "message": "输入数据验证失败",   // 错误概要
    "details": [                      // 详细错误信息
      { 
        "field": "title",            // 出错的字段
        "message": "标题不能为空"     // 具体错误描述
      }
    ]
  }
}
```

### 3.2.3 API 版本管理策略

API 版本管理就像软件的「时间线」，让我们能够在不影响现有功能的前提下进行迭代更新：

```
/api/v1/...    # 当前稳定版本，所有生产环境使用
/api/v2/...    # 开发中的下一版本，包含新功能和改进
```

通过版本号区分不同阶段的 API，可以确保向后兼容性，同时为新功能开发提供灵活的空间。

## 3.3 数据库选型与 SQLAlchemy 实践

数据库就像是网站的「记忆仓库」，负责存储和管理所有数据。我们选择 SQLAlchemy 作为 ORM （对象关系映射） 工具，并根据不同环境选择合适的数据库：

### 3.3.1 开发环境 - SQLite

在开发阶段，我们选择 SQLite 作为数据库，它就像一个轻便的「笔记本」，无需额外配置即可使用：

```python
# 优势
- 零配置，文件式数据库，随项目一起移动
- 适合开发和测试环境，启动迅速
- 快速原型开发的理想选择
- 占用资源少，对于小型项目足够高效

# 配置示例
DATABASE_URL = "sqlite:///./app.db"  # 简单的文件路径配置
```

### 3.3.2 生产环境 - PostgreSQL

在生产环境中，我们选择 PostgreSQL 作为数据库，它就像一个功能强大的「专业仓库」，能够应对高并发和复杂查询：

```python
# 优势
- 高性能，支持高并发访问
- 丰富的功能特性，如 JSON 支持、全文搜索等
- 完善的数据完整性保障机制
- 优秀的扩展性和稳定性
- 社区活跃，文档完善

# 配置示例
DATABASE_URL = "postgresql://user:pass@localhost:5432/dbname"  # 连接生产数据库
```

### SQLAlchemy 数据模型设计

SQLAlchemy 让我们能够用面向对象的方式定义数据模型，就像设计「数据蓝图」一样：

```python
# SQLAlchemy 模型定义示例
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime

class User(Base):
    __tablename__ = "users"  # 数据库表名
    
    id = Column(Integer, primary_key=True, index=True)  # 主键
    email = Column(String, unique=True, index=True)     # 唯一索引
    hashed_password = Column(String)                    # 密码（已加密）
    is_active = Column(Boolean, default=True)           # 用户状态
    created_at = Column(DateTime, default=datetime.utcnow)  # 创建时间
    
    # 关系定义 - 一个用户可以有多篇文章
    articles = relationship("Article", back_populates="author")

class Article(Base):
    __tablename__ = "articles"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)  # 索引字段，提高查询效率
    content = Column(Text)              # 文章内容
    author_id = Column(Integer, ForeignKey("users.id"))  # 外键，关联用户表
    
    # 关系定义 - 一篇文章属于一个作者
    author = relationship("User", back_populates="articles")
    # 多对多关系 - 文章可以有多个标签
    tags = relationship("Tag", secondary="article_tags")
```

SQLAlchemy 的强大之处在于它不仅提供了简单的 CRUD 操作，还支持复杂查询、事务管理、数据迁移等高级功能，是 Python 生态系统中最成熟的 ORM 工具之一。

## 3.4 开发工作流与协作规范

良好的开发工作流就像一套「交通规则」，确保团队成员能够高效协作而不会相互干扰。

### Git 分支策略概述

Git 分支管理就像项目的「分支树」，不同分支承担不同的开发阶段和任务：

```
main 分支      - 生产环境代码，保持稳定可部署状态
develop 分支   - 开发集成分支，汇集所有功能开发成果
feature/*      - 功能开发分支，每个新功能在独立分支中开发
release/*      - 发布准备分支，为生产环境发布做最后准备
hotfix/*       - 紧急修复分支，处理生产环境中的突发问题
```

### 代码审查流程

代码审查就像「质量检查关卡」，确保所有代码符合质量标准：

```markdown
1. 创建功能分支 - 在独立的分支中开发新功能
2. 开发并提交代码 - 定期提交，保持提交信息清晰
3. 创建 Pull Request - 向团队展示你的工作成果
4. 代码审查 - 至少 1 名团队成员审核代码，提出改进建议
5. 自动化测试 - 确保代码通过所有测试用例
6. 合并到 develop 分支 - 代码通过审查后合并到开发分支
```

### 自动化脚本配置

自动化脚本就像「智能助手」，帮助我们简化重复的开发任务：

```json
// 前端 package.json 脚本
{
  "scripts": {
    "dev": "nuxt dev",  // 启动前端开发服务器
    "dev:all": "concurrently \"pnpm dev\" \"cd backend && python -m uvicorn app.main:app --reload\"",  // 同时启动前后端开发服务
    "build": "nuxt build",  // 构建生产版本
    "lint": "eslint .",  // 代码质量检查
    "type-check": "nuxt type-check"  // TypeScript 类型检查
  }
}
```

```toml
# 后端 pyproject.toml 任务配置
[tool.taskipy.tasks]
# 使用 taskipy 管理后端开发任务
# 启动后端开发服务器，支持热重载
dev = "uvicorn app.main:app --reload --host 0.0.0.0 --port 8000"
# 运行测试用例
test = "pytest"
# 代码风格检查
lint = "flake8 app tests"
# 代码格式化
format = "black app tests"
```

通过这些自动化脚本，我们可以一键启动开发环境、运行测试、检查代码质量等，大大提高了开发效率。

通过以上架构设计和技术选型，我们为个人网站项目建立了一个清晰、可维护、可扩展的全栈开发基础，就像搭建了一座坚固的「数字建筑框架」，为后续的功能开发奠定了坚实的基础。